#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_EXT_ray_query : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "ray_tracing_lang.glsl"
#include "ray_query_lang.glsl"
#include "constants.glsl"
#include "scene.glsl"
#include "util.glsl"
#include "sampling.glsl"
#include "scene_push_constants.glsl"

layout(set = 0, binding = 0) uniform accelerationStructure topLevelAs;

layout(location = 0) rayPayloadIn HitData hitData;

hitAttribute vec2 attribs;

void main(){
    SurfaceRef ref;
    vec3 wo = -gl_WorldRayDirection;
    ref.objToWorld = gl_ObjectToWorld;
    ref.attribs = attribs;
    ref.instanceId = gl_InstanceID;
    ref.vertexOffsetId = gl_InstanceCustomIndex;
    ref.primitiveId = gl_PrimitiveID;
    Surface surface = getSurfaceData(ref, wo);
    surface.volume = true;

    vec3 origin;
    if(surface.inside){     // FIXME if we already inside the surface we don't need to shoot another ray
        surface.x += surface.gN * gl_HitT;
        origin = surface.x;
    }else{
        origin = offsetRay(surface.x, -surface.gN);
    }

    vec3 direction = gl_WorldRayDirection;

    rayQuery rQuery;
    rayQueryInitialize(rQuery, topLevelAs, gl_RayFlagsNoOpaque, mask, origin, 0, direction, gl_RayTmax);
    while(rayQueryProceed(rQuery)){
        if(rayQueryGetIntersectionInstanceId(rQuery, false) != gl_InstanceID){
            continue;
        }
        rayQueryConfirmIntersection(rQuery);
    }

    if(rayQueryGetIntersectionType(rQuery, true) == gl_RayQueryCommittedIntersectionNone){
        ignoreIntersection;
        return;
    }else{

        ref.objToWorld = rayQueryGetIntersectionObjectToWorld(rQuery, true);
        ref.attribs = rayQueryGetIntersectionBarycentrics(rQuery, true);
        ref.instanceId = rayQueryGetIntersectionInstanceId(rQuery, true);
        ref.vertexOffsetId = rayQueryGetIntersectionInstanceCustomIndex(rQuery, true);
        ref.primitiveId = rayQueryGetIntersectionPrimitiveIndex(rQuery, true);
        Surface surface1 = getSurfaceData(ref, wo);

        if(surface.id != surface1.id){
            ignoreIntersection;
            return;
        }

        float density = surface.opacity;
        float dist = rayQueryGetIntersectionT(rQuery, true);
        float hitDistance = (-1/density) * log(1 - rand(hitData.rngState));

        if(hitDistance > dist){
            ignoreIntersection;
            return;
        }

        hitData.hit = true;
        hitData.surface = surface;
        hitData.ray.origin = surface.x;
        hitData.surface.gN = vec3(1, 0, 0);
        hitData.surface.sN = vec3(1, 0, 0);
        hitData.ray.direction = uniformSampleSphere(randomVec3(hitData.rngState));
        hitData.transmission = surface.albedo * vec3(exp(-density * hitDistance));
        terminateRay;
    }

    return;
}